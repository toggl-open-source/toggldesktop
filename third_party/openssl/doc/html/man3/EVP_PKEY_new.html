<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>EVP_PKEY_new</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@manhattan72.ta10.sd.apple.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#NOTES">NOTES</a></li>
  <li><a href="#RETURN-VALUES">RETURN VALUES</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#HISTORY">HISTORY</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>EVP_PKEY_new, EVP_PKEY_up_ref, EVP_PKEY_free, EVP_PKEY_new_raw_private_key_with_libctx, EVP_PKEY_new_raw_private_key, EVP_PKEY_new_raw_public_key_with_libctx, EVP_PKEY_new_raw_public_key, EVP_PKEY_new_CMAC_key_with_libctx, EVP_PKEY_new_CMAC_key, EVP_PKEY_new_mac_key, EVP_PKEY_get_raw_private_key, EVP_PKEY_get_raw_public_key - public/private key allocation and raw key handling functions</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> #include &lt;openssl/evp.h&gt;

 EVP_PKEY *EVP_PKEY_new(void);
 int EVP_PKEY_up_ref(EVP_PKEY *key);
 void EVP_PKEY_free(EVP_PKEY *key);

 EVP_PKEY *EVP_PKEY_new_raw_private_key_with_libctx(OPENSSL_CTX *libctx,
                                                    const char *keytype,
                                                    const char *propq,
                                                    const unsigned char *key,
                                                    size_t keylen);
 EVP_PKEY *EVP_PKEY_new_raw_private_key(int type, ENGINE *e,
                                        const unsigned char *key, size_t keylen);
 EVP_PKEY *EVP_PKEY_new_raw_public_key_with_libctx(OPENSSL_CTX *libctx,
                                                   const char *keytype,
                                                   const char *propq,
                                                   const unsigned char *key,
                                                   size_t keylen);
 EVP_PKEY *EVP_PKEY_new_raw_public_key(int type, ENGINE *e,
                                       const unsigned char *key, size_t keylen);
 EVP_PKEY *EVP_PKEY_new_CMAC_key_with_libctx(const unsigned char *priv,
                                             size_t len,
                                             const char *cipher_name,
                                             OPENSSL_CTX *libctx,
                                             const char *propq);
 EVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *e, const unsigned char *priv,
                                 size_t len, const EVP_CIPHER *cipher);
 EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e, const unsigned char *key,
                                int keylen);

 int EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv,
                                  size_t *len);
 int EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub,
                                 size_t *len);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The EVP_PKEY_new() function allocates an empty <b>EVP_PKEY</b> structure which is used by OpenSSL to store public and private keys. The reference count is set to <b>1</b>.</p>

<p>EVP_PKEY_up_ref() increments the reference count of <i>key</i>.</p>

<p>EVP_PKEY_free() decrements the reference count of <i>key</i> and, if the reference count is zero, frees it up. If <i>key</i> is NULL, nothing is done.</p>

<p>EVP_PKEY_new_raw_private_key_with_libctx() allocates a new <b>EVP_PKEY</b>. Unless an engine should be used for the key type, a provider for the key is found using the library context <i>libctx</i> and the property query string <i>propq</i>. The <i>keytype</i> argument indicates what kind of key this is. The value should be a string for a public key algorithm that supports raw private keys, i.e one of &quot;POLY1305&quot;, &quot;SIPHASH&quot;, &quot;X25519&quot;, &quot;ED25519&quot;, &quot;X448&quot; or &quot;ED448&quot;. Note that you may also use &quot;HMAC&quot; which is not a public key algorithm but is treated as such by some OpenSSL APIs. You are encouraged to use the EVP_MAC APIs instead for HMAC (see <a href="../man3/EVP_MAC.html">EVP_MAC(3)</a>). <i>key</i> points to the raw private key data for this <b>EVP_PKEY</b> which should be of length <i>keylen</i>. The length should be appropriate for the type of the key. The public key data will be automatically derived from the given private key data (if appropriate for the algorithm type).</p>

<p>EVP_PKEY_new_raw_private_key() does the same as EVP_PKEY_new_raw_private_key_with_libctx() except that the default library context and default property query are used instead. If <i>e</i> is non-NULL then the new <b>EVP_PKEY</b> structure is associated with the engine <i>e</i>. The <i>type</i> argument indicates what kind of key this is. The value should be a NID for a public key algorithm that supports raw private keys, i.e. one of <b>EVP_PKEY_POLY1305</b>, <b>EVP_PKEY_SIPHASH</b>, <b>EVP_PKEY_X25519</b>, <b>EVP_PKEY_ED25519</b>, <b>EVP_PKEY_X448</b> or <b>EVP_PKEY_ED448</b>. As for EVP_PKEY_new_raw_private_key_with_libctx() you may also use <b>EVP_PKEY_HMAC</b>.</p>

<p>EVP_PKEY_new_raw_public_key_with_libctx() works in the same way as EVP_PKEY_new_raw_private_key_with_libctx() except that <i>key</i> points to the raw public key data. The <b>EVP_PKEY</b> structure will be initialised without any private key information. Algorithm types that support raw public keys are &quot;X25519&quot;, &quot;ED25519&quot;, &quot;X448&quot; or &quot;ED448&quot;.</p>

<p>EVP_PKEY_new_raw_public_key() works in the same way as EVP_PKEY_new_raw_private_key() except that <i>key</i> points to the raw public key data. The <b>EVP_PKEY</b> structure will be initialised without any private key information. Algorithm types that support raw public keys are <b>EVP_PKEY_X25519</b>, <b>EVP_PKEY_ED25519</b>, <b>EVP_PKEY_X448</b> or <b>EVP_PKEY_ED448</b>.</p>

<p>EVP_PKEY_new_CMAC_key_with_libctx() works in the same way as EVP_PKEY_new_raw_private_key() except it is only for the <b>EVP_PKEY_CMAC</b> algorithm type. In addition to the raw private key data, it also takes a cipher algorithm to be used during creation of a CMAC in the <i>cipher</i> argument. The cipher should be a standard encryption only cipher. For example AEAD and XTS ciphers should not be used. Finally it also takes a library context <i>libctx</i> and property query <i>propq</i> which are used when fetching any cryptographic algorithms which may be NULL to use the default values.</p>

<p>EVP_PKEY_new_CMAC_key() is the same as EVP_PKEY_new_CMAC_key_with_libctx() except that the default values are used for <i>libctx</i> and <i>propq</i>.</p>

<p>EVP_PKEY_new_mac_key() works in the same way as EVP_PKEY_new_raw_private_key(). New applications should use EVP_PKEY_new_raw_private_key() instead.</p>

<p>EVP_PKEY_get_raw_private_key() fills the buffer provided by <i>priv</i> with raw private key data. The size of the <i>priv</i> buffer should be in <i>*len</i> on entry to the function, and on exit <i>*len</i> is updated with the number of bytes actually written. If the buffer <i>priv</i> is NULL then <i>*len</i> is populated with the number of bytes required to hold the key. The calling application is responsible for ensuring that the buffer is large enough to receive the private key data. This function only works for algorithms that support raw private keys. Currently this is: <b>EVP_PKEY_HMAC</b>, <b>EVP_PKEY_POLY1305</b>, <b>EVP_PKEY_SIPHASH</b>, <b>EVP_PKEY_X25519</b>, <b>EVP_PKEY_ED25519</b>, <b>EVP_PKEY_X448</b> or <b>EVP_PKEY_ED448</b>.</p>

<p>EVP_PKEY_get_raw_public_key() fills the buffer provided by <i>pub</i> with raw public key data. The size of the <i>pub</i> buffer should be in <i>*len</i> on entry to the function, and on exit <i>*len</i> is updated with the number of bytes actually written. If the buffer <i>pub</i> is NULL then <i>*len</i> is populated with the number of bytes required to hold the key. The calling application is responsible for ensuring that the buffer is large enough to receive the public key data. This function only works for algorithms that support raw public keys. Currently this is: <b>EVP_PKEY_X25519</b>, <b>EVP_PKEY_ED25519</b>, <b>EVP_PKEY_X448</b> or <b>EVP_PKEY_ED448</b>.</p>

<h1 id="NOTES">NOTES</h1>

<p>The <b>EVP_PKEY</b> structure is used by various OpenSSL functions which require a general private key without reference to any particular algorithm.</p>

<p>The structure returned by EVP_PKEY_new() is empty. To add a private or public key to this empty structure use the appropriate functions described in <a href="../man3/EVP_PKEY_set1_RSA.html">EVP_PKEY_set1_RSA(3)</a>, <a href="../man3/EVP_PKEY_set1_DSA.html">EVP_PKEY_set1_DSA(3)</a>, <a href="../man3/EVP_PKEY_set1_DH.html">EVP_PKEY_set1_DH(3)</a> or <a href="../man3/EVP_PKEY_set1_EC_KEY.html">EVP_PKEY_set1_EC_KEY(3)</a>.</p>

<h1 id="RETURN-VALUES">RETURN VALUES</h1>

<p>EVP_PKEY_new(), EVP_PKEY_new_raw_private_key(), EVP_PKEY_new_raw_public_key(), EVP_PKEY_new_CMAC_key() and EVP_PKEY_new_mac_key() return either the newly allocated <b>EVP_PKEY</b> structure or <b>NULL</b> if an error occurred.</p>

<p>EVP_PKEY_up_ref(), EVP_PKEY_get_raw_private_key() and EVP_PKEY_get_raw_public_key() return 1 for success and 0 for failure.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../man3/EVP_PKEY_set1_RSA.html">EVP_PKEY_set1_RSA(3)</a>, <a href="../man3/EVP_PKEY_set1_DSA.html">EVP_PKEY_set1_DSA(3)</a>, <a href="../man3/EVP_PKEY_set1_DH.html">EVP_PKEY_set1_DH(3)</a> or <a href="../man3/EVP_PKEY_set1_EC_KEY.html">EVP_PKEY_set1_EC_KEY(3)</a></p>

<h1 id="HISTORY">HISTORY</h1>

<p>The EVP_PKEY_new() and EVP_PKEY_free() functions exist in all versions of OpenSSL.</p>

<p>The EVP_PKEY_up_ref() function was added in OpenSSL 1.1.0.</p>

<p>The EVP_PKEY_new_raw_private_key(), EVP_PKEY_new_raw_public_key(), EVP_PKEY_new_CMAC_key(), EVP_PKEY_new_raw_private_key() and EVP_PKEY_get_raw_public_key() functions were added in OpenSSL 1.1.1.</p>

<p>The EVP_PKEY_new_raw_private_key_with_libctx(), EVP_PKEY_new_raw_public_key_with_libctx() and EVP_PKEY_new_CMAC_key_with_libctx() functions were added in OpenSSL 3.0.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2002-2020 The OpenSSL Project Authors. All Rights Reserved.</p>

<p>Licensed under the Apache License 2.0 (the &quot;License&quot;). You may not use this file except in compliance with the License. You can obtain a copy in the file LICENSE in the source distribution or at <a href="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</a>.</p>


</body>

</html>


