.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ERR_PUT_ERROR 3"
.TH ERR_PUT_ERROR 3 "2020-09-17" "3.0.0-alpha7-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ERR_raise, ERR_raise_data,
ERR_put_error, ERR_add_error_data, ERR_add_error_vdata,
ERR_add_error_txt, ERR_add_error_mem_bio
\&\- record an error
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/err.h>
\&
\& void ERR_raise(int lib, int reason);
\& void ERR_raise_data(int lib, int reason, const char *fmt, ...);
\&
\& void ERR_add_error_data(int num, ...);
\& void ERR_add_error_vdata(int num, va_list arg);
\& void ERR_add_error_txt(const char *sep, const char *txt);
\& void ERR_add_error_mem_bio(const char *sep, BIO *bio);
.Ve
.PP
Deprecated since OpenSSL 3.0:
.PP
.Vb 1
\& void ERR_put_error(int lib, int func, int reason, const char *file, int line);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBERR_raise()\fR adds a new error to the thread's error queue.  The
error occurred in the library \fBlib\fR for the reason given by the
\&\fBreason\fR code.  Furthermore, the name of the file, the line, and name
of the function where the error occurred is saved with the error
record.
.PP
\&\fBERR_raise_data()\fR does the same thing as \fBERR_raise()\fR, but also lets the
caller specify additional information as a format string \fBfmt\fR and an
arbitrary number of values, which are processed with \fBBIO_snprintf\fR\|(3).
.PP
\&\fBERR_put_error()\fR adds an error code to the thread's error queue. It
signals that the error of reason code \fBreason\fR occurred in function
\&\fBfunc\fR of library \fBlib\fR, in line number \fBline\fR of \fBfile\fR.
This function is usually called by a macro.
.PP
\&\fBERR_add_error_data()\fR associates the concatenation of its \fBnum\fR string
arguments as additional data with the error code added last.
\&\fBERR_add_error_vdata()\fR is similar except the argument is a \fBva_list\fR.
Multiple calls to these functions append to the current top of the error queue.
The total length of the string data per error is limited to 4096 characters.
.PP
\&\fBERR_add_error_txt()\fR appends the given text string as additional data to the
last error queue entry, after inserting the optional separator string if it is
not \s-1NULL\s0 and the top error entry does not yet have additional data.
In case the separator is at the end of the text it is not appended to the data.
The \fBsep\fR argument may be for instance \*(L"\en\*(R" to insert a line break when needed.
If the associated data would become more than 4096 characters long
(which is the limit given above)
it is split over sufficiently many new copies of the last error queue entry.
.PP
\&\fBERR_add_error_mem_bio()\fR is the same as \fBERR_add_error_txt()\fR except that
the text string is taken from the given memory \s-1BIO.\s0
It appends '\e0' to the \s-1BIO\s0 contents if not already NUL-terminated.
.PP
\&\fBERR_load_strings\fR\|(3) can be used to register
error strings so that the application can a generate human-readable
error messages for the error code.
.SS "Reporting errors"
.IX Subsection "Reporting errors"
Each sub-library has a specific macro \fBXXXerr()\fR that is used to report
errors. Its first argument is a function code \fB\s-1XXX_F_...\s0\fR, the second
argument is a reason code \fB\s-1XXX_R_...\s0\fR. Function codes are derived
from the function names; reason codes consist of textual error
descriptions. For example, the function \fBssl3_read_bytes()\fR reports a
\&\*(L"handshake failure\*(R" as follows:
.PP
.Vb 1
\& SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
.Ve
.PP
Function and reason codes should consist of uppercase characters,
numbers and underscores only. The error file generation script translates
function codes into function names by looking in the header files
for an appropriate function name, if none is found it just uses
the capitalized form such as \*(L"\s-1SSL3_READ_BYTES\*(R"\s0 in the above example.
.PP
The trailing section of a reason code (after the \*(L"_R_\*(R") is translated
into lowercase and underscores changed to spaces.
.PP
Although a library will normally report errors using its own specific
XXXerr macro, another library's macro can be used. This is normally
only done when a library wants to include \s-1ASN1\s0 code which must use
the \fBASN1err()\fR macro.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBERR_raise()\fR, \fBERR_put_error()\fR,
\&\fBERR_add_error_data()\fR, \fBERR_add_error_vdata()\fR
\&\fBERR_add_error_txt()\fR, and \fBERR_add_error_mem_bio()\fR
return no values.
.SH "NOTES"
.IX Header "NOTES"
\&\fBERR_raise()\fR and \fBERR_put_error()\fR are implemented as macros.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBERR_load_strings\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fBERR_add_error_txt\fR and \fBERR_add_error_mem_bio\fR were added in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
