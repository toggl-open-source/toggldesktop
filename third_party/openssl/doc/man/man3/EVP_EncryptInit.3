.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_ENCRYPTINIT 3"
.TH EVP_ENCRYPTINIT 3 "2020-09-17" "3.0.0-alpha7-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_CIPHER_fetch,
EVP_CIPHER_up_ref,
EVP_CIPHER_free,
EVP_CIPHER_CTX_new,
EVP_CIPHER_CTX_reset,
EVP_CIPHER_CTX_free,
EVP_EncryptInit_ex,
EVP_EncryptUpdate,
EVP_EncryptFinal_ex,
EVP_DecryptInit_ex,
EVP_DecryptUpdate,
EVP_DecryptFinal_ex,
EVP_CipherInit_ex,
EVP_CipherUpdate,
EVP_CipherFinal_ex,
EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl,
EVP_EncryptInit,
EVP_EncryptFinal,
EVP_DecryptInit,
EVP_DecryptFinal,
EVP_CipherInit,
EVP_CipherFinal,
EVP_Cipher,
EVP_get_cipherbyname,
EVP_get_cipherbynid,
EVP_get_cipherbyobj,
EVP_CIPHER_is_a,
EVP_CIPHER_name,
EVP_CIPHER_number,
EVP_CIPHER_names_do_all,
EVP_CIPHER_provider,
EVP_CIPHER_nid,
EVP_CIPHER_get_params,
EVP_CIPHER_gettable_params,
EVP_CIPHER_block_size,
EVP_CIPHER_key_length,
EVP_CIPHER_iv_length,
EVP_CIPHER_flags,
EVP_CIPHER_mode,
EVP_CIPHER_type,
EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_name,
EVP_CIPHER_CTX_nid,
EVP_CIPHER_CTX_get_params,
EVP_CIPHER_gettable_ctx_params,
EVP_CIPHER_CTX_set_params,
EVP_CIPHER_settable_ctx_params,
EVP_CIPHER_CTX_block_size,
EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length,
EVP_CIPHER_CTX_tag_length,
EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data,
EVP_CIPHER_CTX_type,
EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_mode,
EVP_CIPHER_param_to_asn1,
EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding,
EVP_enc_null,
EVP_CIPHER_do_all_provided
\&\- EVP cipher routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& EVP_CIPHER *EVP_CIPHER_fetch(OPENSSL_CTX *ctx, const char *algorithm,
\&                              const char *properties);
\& int EVP_CIPHER_up_ref(EVP_CIPHER *cipher);
\& void EVP_CIPHER_free(EVP_CIPHER *cipher);
\& EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
\& int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *ctx);
\& void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx);
\&
\& int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                        ENGINE *impl, const unsigned char *key, const unsigned char *iv);
\& int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&                       int *outl, const unsigned char *in, int inl);
\& int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
\&
\& int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                        ENGINE *impl, const unsigned char *key, const unsigned char *iv);
\& int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&                       int *outl, const unsigned char *in, int inl);
\& int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
\&
\& int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                       ENGINE *impl, const unsigned char *key, const unsigned char *iv, int enc);
\& int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&                      int *outl, const unsigned char *in, int inl);
\& int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
\&
\& int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                     const unsigned char *key, const unsigned char *iv);
\& int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
\&
\& int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                     const unsigned char *key, const unsigned char *iv);
\& int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
\&
\& int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                    const unsigned char *key, const unsigned char *iv, int enc);
\& int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
\&
\& int EVP_Cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&                const unsigned char *in, unsigned int inl);
\&
\& int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
\& int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
\& int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
\& int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);
\&
\& const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
\& const EVP_CIPHER *EVP_get_cipherbynid(int nid);
\& const EVP_CIPHER *EVP_get_cipherbyobj(const ASN1_OBJECT *a);
\&
\& int EVP_CIPHER_nid(const EVP_CIPHER *e);
\& int EVP_CIPHER_number(const EVP_CIPHER *e);
\& int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name);
\& void EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
\&                              void (*fn)(const char *name, void *data),
\&                              void *data);
\& const char *EVP_CIPHER_name(const EVP_CIPHER *cipher);
\& const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher);
\& int EVP_CIPHER_block_size(const EVP_CIPHER *e);
\& int EVP_CIPHER_key_length(const EVP_CIPHER *e);
\& int EVP_CIPHER_iv_length(const EVP_CIPHER *e);
\& unsigned long EVP_CIPHER_flags(const EVP_CIPHER *e);
\& unsigned long EVP_CIPHER_mode(const EVP_CIPHER *e);
\& int EVP_CIPHER_type(const EVP_CIPHER *ctx);
\&
\& const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
\& int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
\& const char *EVP_CIPHER_CTX_name(const EVP_CIPHER_CTX *ctx);
\&
\& int EVP_CIPHER_get_params(EVP_CIPHER *cipher, OSSL_PARAM params[]);
\& int EVP_CIPHER_CTX_set_params(EVP_CIPHER_CTX *ctx, const OSSL_PARAM params[]);
\& int EVP_CIPHER_CTX_get_params(EVP_CIPHER_CTX *ctx, OSSL_PARAM params[]);
\& const OSSL_PARAM *EVP_CIPHER_gettable_params(const EVP_CIPHER *cipher);
\& const OSSL_PARAM *EVP_CIPHER_settable_ctx_params(const EVP_CIPHER *cipher);
\& const OSSL_PARAM *EVP_CIPHER_gettable_ctx_params(const EVP_CIPHER *cipher);
\& int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
\& int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
\& int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
\& int EVP_CIPHER_CTX_tag_length(const EVP_CIPHER_CTX *ctx);
\& void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
\& void EVP_CIPHER_CTX_set_app_data(const EVP_CIPHER_CTX *ctx, void *data);
\& int EVP_CIPHER_CTX_type(const EVP_CIPHER_CTX *ctx);
\& int EVP_CIPHER_CTX_mode(const EVP_CIPHER_CTX *ctx);
\&
\& int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
\& int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
\&
\& void EVP_CIPHER_do_all_provided(OPENSSL_CTX *libctx,
\&                                 void (*fn)(EVP_CIPHER *cipher, void *arg),
\&                                 void *arg);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1EVP\s0 cipher routines are a high-level interface to certain
symmetric ciphers.
.PP
The \fB\s-1EVP_CIPHER\s0\fR type is a structure for cipher method implementation.
.PP
\&\fBEVP_CIPHER_fetch()\fR fetches the cipher implementation for the given
\&\fBalgorithm\fR from any provider offering it, within the criteria given
by the \fBproperties\fR.
See \*(L"Fetching algorithms\*(R" in \fBprovider\fR\|(7) for further information.
.PP
The returned value must eventually be freed with \fBEVP_CIPHER_free()\fR.
.PP
\&\fBEVP_CIPHER_up_ref()\fR increments the reference count for an \fB\s-1EVP_CIPHER\s0\fR
structure.
.PP
\&\fBEVP_CIPHER_free()\fR decrements the reference count for the \fB\s-1EVP_CIPHER\s0\fR
structure.
If the reference count drops to 0 then the structure is freed.
.PP
\&\fBEVP_CIPHER_CTX_new()\fR creates a cipher context.
.PP
\&\fBEVP_CIPHER_CTX_free()\fR clears all information from a cipher context
and free up any allocated memory associate with it, including \fBctx\fR
itself. This function should be called after all operations using a
cipher are complete so sensitive information does not remain in
memory.
.PP
\&\fBEVP_EncryptInit_ex()\fR sets up cipher context \fBctx\fR for encryption
with cipher \fBtype\fR. \fBtype\fR is typically supplied by a function such
as \fBEVP_aes_256_cbc()\fR, or a value explicitly fetched with
\&\fBEVP_CIPHER_fetch()\fR. If \fBimpl\fR is non-NULL, its implementation of the
cipher \fBtype\fR is used if there is one, and if not, the default
implementation is used. \fBkey\fR is the symmetric key to use
and \fBiv\fR is the \s-1IV\s0 to use (if necessary), the actual number of bytes
used for the key and \s-1IV\s0 depends on the cipher. It is possible to set
all parameters to \s-1NULL\s0 except \fBtype\fR in an initial call and supply
the remaining parameters in subsequent calls, all of which have \fBtype\fR
set to \s-1NULL.\s0 This is done when the default cipher parameters are not
appropriate.
For \s-1EVP_CIPH_GCM_MODE\s0 the \s-1IV\s0 will be generated internally if it is not
specified.
.PP
\&\fBEVP_EncryptUpdate()\fR encrypts \fBinl\fR bytes from the buffer \fBin\fR and
writes the encrypted version to \fBout\fR. This function can be called
multiple times to encrypt successive blocks of data. The amount
of data written depends on the block alignment of the encrypted data.
For most ciphers and modes, the amount of data written can be anything
from zero bytes to (inl + cipher_block_size \- 1) bytes.
For wrap cipher modes, the amount of data written can be anything
from zero bytes to (inl + cipher_block_size) bytes.
For stream ciphers, the amount of data written can be anything from zero
bytes to inl bytes.
Thus, \fBout\fR should contain sufficient room for the operation being performed.
The actual number of bytes written is placed in \fBoutl\fR. It also
checks if \fBin\fR and \fBout\fR are partially overlapping, and if they are
0 is returned to indicate failure.
.PP
If padding is enabled (the default) then \fBEVP_EncryptFinal_ex()\fR encrypts
the \*(L"final\*(R" data, that is any data that remains in a partial block.
It uses standard block padding (aka \s-1PKCS\s0 padding) as described in
the \s-1NOTES\s0 section, below. The encrypted
final data is written to \fBout\fR which should have sufficient space for
one cipher block. The number of bytes written is placed in \fBoutl\fR. After
this function is called the encryption operation is finished and no further
calls to \fBEVP_EncryptUpdate()\fR should be made.
.PP
If padding is disabled then \fBEVP_EncryptFinal_ex()\fR will not encrypt any more
data and it will return an error if any data remains in a partial block:
that is if the total data length is not a multiple of the block size.
.PP
\&\fBEVP_DecryptInit_ex()\fR, \fBEVP_DecryptUpdate()\fR and \fBEVP_DecryptFinal_ex()\fR are the
corresponding decryption operations. \fBEVP_DecryptFinal()\fR will return an
error code if padding is enabled and the final block is not correctly
formatted. The parameters and restrictions are identical to the encryption
operations except that if padding is enabled the decrypted data buffer \fBout\fR
passed to \fBEVP_DecryptUpdate()\fR should have sufficient room for
(\fBinl\fR + cipher_block_size) bytes unless the cipher block size is 1 in
which case \fBinl\fR bytes is sufficient.
.PP
\&\fBEVP_CipherInit_ex()\fR, \fBEVP_CipherUpdate()\fR and \fBEVP_CipherFinal_ex()\fR are
functions that can be used for decryption or encryption. The operation
performed depends on the value of the \fBenc\fR parameter. It should be set
to 1 for encryption, 0 for decryption and \-1 to leave the value unchanged
(the actual value of 'enc' being supplied in a previous call).
.PP
\&\fBEVP_CIPHER_CTX_reset()\fR clears all information from a cipher context
and free up any allocated memory associate with it, except the \fBctx\fR
itself. This function should be called anytime \fBctx\fR is to be reused
for another \fBEVP_CipherInit()\fR / \fBEVP_CipherUpdate()\fR / \fBEVP_CipherFinal()\fR
series of calls.
.PP
\&\fBEVP_EncryptInit()\fR, \fBEVP_DecryptInit()\fR and \fBEVP_CipherInit()\fR behave in a
similar way to \fBEVP_EncryptInit_ex()\fR, \fBEVP_DecryptInit_ex()\fR and
\&\fBEVP_CipherInit_ex()\fR except they always use the default cipher implementation.
.PP
\&\fBEVP_EncryptFinal()\fR, \fBEVP_DecryptFinal()\fR and \fBEVP_CipherFinal()\fR are
identical to \fBEVP_EncryptFinal_ex()\fR, \fBEVP_DecryptFinal_ex()\fR and
\&\fBEVP_CipherFinal_ex()\fR. In previous releases they also cleaned up
the \fBctx\fR, but this is no longer done and \fBEVP_CIPHER_CTX_clean()\fR
must be called to free any context resources.
.PP
\&\fBEVP_Cipher()\fR encrypts or decrypts a maximum \fIinl\fR amount of bytes from
\&\fIin\fR and leaves the result in \fIout\fR.
If the cipher doesn't have the flag \fB\s-1EVP_CIPH_FLAG_CUSTOM_CIPHER\s0\fR set,
then \fIinl\fR must be a multiple of \fBEVP_CIPHER_block_size()\fR.  If it isn't,
the result is undefined.  If the cipher has that flag set, then \fIinl\fR
can be any size.
This function is historic and shouldn't be used in an application, please
consider using \fBEVP_CipherUpdate()\fR and EVP_CipherFinal_ex instead.
.PP
\&\fBEVP_get_cipherbyname()\fR, \fBEVP_get_cipherbynid()\fR and \fBEVP_get_cipherbyobj()\fR
return an \s-1EVP_CIPHER\s0 structure when passed a cipher name, a \s-1NID\s0 or an
\&\s-1ASN1_OBJECT\s0 structure.
.PP
\&\fBEVP_CIPHER_nid()\fR and \fBEVP_CIPHER_CTX_nid()\fR return the \s-1NID\s0 of a cipher when
passed an \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR structure.  The actual \s-1NID\s0
value is an internal value which may not have a corresponding \s-1OBJECT
IDENTIFIER.\s0
.PP
\&\fBEVP_CIPHER_CTX_set_padding()\fR enables or disables padding. This
function should be called after the context is set up for encryption
or decryption with \fBEVP_EncryptInit_ex()\fR, \fBEVP_DecryptInit_ex()\fR or
\&\fBEVP_CipherInit_ex()\fR. By default encryption operations are padded using
standard block padding and the padding is checked and removed when
decrypting. If the \fBpad\fR parameter is zero then no padding is
performed, the total amount of data encrypted or decrypted must then
be a multiple of the block size or an error will occur.
.PP
\&\fBEVP_CIPHER_get_params()\fR retrieves the requested list of algorithm
\&\fBparams\fR from a \fBcipher\fR.
.PP
\&\fBEVP_CIPHER_CTX_set_params()\fR Sets the list of operation \fBparams\fR into a \s-1CIPHER\s0
context \fBctx\fR.
.PP
\&\fBEVP_CIPHER_CTX_get_params()\fR retrieves the requested list of operation
\&\fBparams\fR from \s-1CIPHER\s0 context \fBctx\fR.
.PP
\&\fBEVP_CIPHER_gettable_params()\fR, \fBEVP_CIPHER_gettable_ctx_params()\fR, and
\&\fBEVP_CIPHER_settable_ctx_params()\fR get a constant \fB\s-1OSSL_PARAM\s0\fR array
that describes the retrievable and settable parameters, i.e. parameters
that can be used with \fBEVP_CIPHER_get_params()\fR, \fBEVP_CIPHER_CTX_get_params()\fR
and \fBEVP_CIPHER_CTX_set_params()\fR, respectively.
See \s-1\fBOSSL_PARAM\s0\fR\|(3) for the use of \fB\s-1OSSL_PARAM\s0\fR as parameter descriptor.
.PP
\&\fBEVP_CIPHER_key_length()\fR and \fBEVP_CIPHER_CTX_key_length()\fR return the key
length of a cipher when passed an \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR
structure. The constant \fB\s-1EVP_MAX_KEY_LENGTH\s0\fR is the maximum key length
for all ciphers. Note: although \fBEVP_CIPHER_key_length()\fR is fixed for a
given cipher, the value of \fBEVP_CIPHER_CTX_key_length()\fR may be different
for variable key length ciphers.
.PP
\&\fBEVP_CIPHER_CTX_set_key_length()\fR sets the key length of the cipher ctx.
If the cipher is a fixed length cipher then attempting to set the key
length to any value other than the fixed value is an error.
.PP
\&\fBEVP_CIPHER_iv_length()\fR and \fBEVP_CIPHER_CTX_iv_length()\fR return the \s-1IV\s0
length of a cipher when passed an \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR.
It will return zero if the cipher does not use an \s-1IV.\s0  The constant
\&\fB\s-1EVP_MAX_IV_LENGTH\s0\fR is the maximum \s-1IV\s0 length for all ciphers.
.PP
\&\fBEVP_CIPHER_CTX_tag_length()\fR returns the tag length of a \s-1AEAD\s0 cipher when passed
a \fB\s-1EVP_CIPHER_CTX\s0\fR. It will return zero if the cipher does not support a tag.
It returns a default value if the tag length has not been set.
.PP
\&\fBEVP_CIPHER_block_size()\fR and \fBEVP_CIPHER_CTX_block_size()\fR return the block
size of a cipher when passed an \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR
structure. The constant \fB\s-1EVP_MAX_BLOCK_LENGTH\s0\fR is also the maximum block
length for all ciphers.
.PP
\&\fBEVP_CIPHER_type()\fR and \fBEVP_CIPHER_CTX_type()\fR return the type of the passed
cipher or context. This \*(L"type\*(R" is the actual \s-1NID\s0 of the cipher \s-1OBJECT
IDENTIFIER\s0 as such it ignores the cipher parameters and 40 bit \s-1RC2\s0 and
128 bit \s-1RC2\s0 have the same \s-1NID.\s0 If the cipher does not have an object
identifier or does not have \s-1ASN1\s0 support this function will return
\&\fBNID_undef\fR.
.PP
\&\fBEVP_CIPHER_is_a()\fR returns 1 if \fIcipher\fR is an implementation of an
algorithm that's identifiable with \fIname\fR, otherwise 0.
If \fIcipher\fR is a legacy cipher (it's the return value from the likes
of \fBEVP_aes128()\fR rather than the result of an \fBEVP_CIPHER_fetch()\fR), only
cipher names registered with the default library context (see
\&\s-1\fBOPENSSL_CTX\s0\fR\|(3)) will be considered.
.PP
\&\fBEVP_CIPHER_number()\fR returns the internal dynamic number assigned to
the \fIcipher\fR.  This is only useful with fetched \fB\s-1EVP_CIPHER\s0\fRs.
.PP
\&\fBEVP_CIPHER_name()\fR and \fBEVP_CIPHER_CTX_name()\fR return the name of the passed
cipher or context.  For fetched ciphers with multiple names, only one
of them is returned; it's recommended to use \fBEVP_CIPHER_names_do_all()\fR
instead.
.PP
\&\fBEVP_CIPHER_names_do_all()\fR traverses all names for the \fIcipher\fR, and
calls \fIfn\fR with each name and \fIdata\fR.  This is only useful with
fetched \fB\s-1EVP_CIPHER\s0\fRs.
.PP
\&\fBEVP_CIPHER_provider()\fR returns an \fB\s-1OSSL_PROVIDER\s0\fR pointer to the provider
that implements the given \fB\s-1EVP_CIPHER\s0\fR.
.PP
\&\fBEVP_CIPHER_CTX_cipher()\fR returns the \fB\s-1EVP_CIPHER\s0\fR structure when passed
an \fB\s-1EVP_CIPHER_CTX\s0\fR structure.
.PP
\&\fBEVP_CIPHER_mode()\fR and \fBEVP_CIPHER_CTX_mode()\fR return the block cipher mode:
\&\s-1EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE, EVP_CIPH_OFB_MODE,
EVP_CIPH_CTR_MODE, EVP_CIPH_GCM_MODE, EVP_CIPH_CCM_MODE, EVP_CIPH_XTS_MODE,
EVP_CIPH_WRAP_MODE, EVP_CIPH_OCB_MODE\s0 or \s-1EVP_CIPH_SIV_MODE.\s0 If the cipher is a
stream cipher then \s-1EVP_CIPH_STREAM_CIPHER\s0 is returned.
.PP
\&\fBEVP_CIPHER_flags()\fR returns any flags associated with the cipher. See
\&\fBEVP_CIPHER_meth_set_flags()\fR for a list of currently defined flags.
.PP
\&\fBEVP_CIPHER_param_to_asn1()\fR sets the AlgorithmIdentifier \*(L"parameter\*(R" based
on the passed cipher. This will typically include any parameters and an
\&\s-1IV.\s0 The cipher \s-1IV\s0 (if any) must be set when this call is made. This call
should be made before the cipher is actually \*(L"used\*(R" (before any
\&\fBEVP_EncryptUpdate()\fR, \fBEVP_DecryptUpdate()\fR calls for example). This function
may fail if the cipher does not have any \s-1ASN1\s0 support.
.PP
\&\fBEVP_CIPHER_asn1_to_param()\fR sets the cipher parameters based on an \s-1ASN1\s0
AlgorithmIdentifier \*(L"parameter\*(R". The precise effect depends on the cipher
In the case of \s-1RC2,\s0 for example, it will set the \s-1IV\s0 and effective key length.
This function should be called after the base cipher type is set but before
the key is set. For example \fBEVP_CipherInit()\fR will be called with the \s-1IV\s0 and
key set to \s-1NULL,\s0 \fBEVP_CIPHER_asn1_to_param()\fR will be called and finally
\&\fBEVP_CipherInit()\fR again with all parameters except the key set to \s-1NULL.\s0 It is
possible for this function to fail if the cipher does not have any \s-1ASN1\s0 support
or the parameters cannot be set (for example the \s-1RC2\s0 effective key length
is not supported.
.PP
\&\fBEVP_CIPHER_CTX_ctrl()\fR allows various cipher specific parameters to be determined
and set.
.PP
\&\fBEVP_CIPHER_CTX_rand_key()\fR generates a random key of the appropriate length
based on the cipher context. The \s-1EVP_CIPHER\s0 can provide its own random key
generation routine to support keys of a specific form. \fBKey\fR must point to a
buffer at least as big as the value returned by \fBEVP_CIPHER_CTX_key_length()\fR.
.PP
\&\fBEVP_CIPHER_do_all_provided()\fR traverses all ciphers implemented by all activated
providers in the given library context \fIlibctx\fR, and for each of the
implementations, calls the given function \fIfn\fR with the implementation method
and the given \fIarg\fR as argument.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBEVP_CIPHER_fetch()\fR returns a pointer to a \fB\s-1EVP_CIPHER\s0\fR for success
and \fB\s-1NULL\s0\fR for failure.
.PP
\&\fBEVP_CIPHER_up_ref()\fR returns 1 for success or 0 otherwise.
.PP
\&\fBEVP_CIPHER_CTX_new()\fR returns a pointer to a newly created
\&\fB\s-1EVP_CIPHER_CTX\s0\fR for success and \fB\s-1NULL\s0\fR for failure.
.PP
\&\fBEVP_EncryptInit_ex()\fR, \fBEVP_EncryptUpdate()\fR and \fBEVP_EncryptFinal_ex()\fR
return 1 for success and 0 for failure.
.PP
\&\fBEVP_DecryptInit_ex()\fR and \fBEVP_DecryptUpdate()\fR return 1 for success and 0 for failure.
\&\fBEVP_DecryptFinal_ex()\fR returns 0 if the decrypt failed or 1 for success.
.PP
\&\fBEVP_CipherInit_ex()\fR and \fBEVP_CipherUpdate()\fR return 1 for success and 0 for failure.
\&\fBEVP_CipherFinal_ex()\fR returns 0 for a decryption failure or 1 for success.
.PP
\&\fBEVP_Cipher()\fR returns the amount of encrypted / decrypted bytes, or \-1
on failure, if the flag \fB\s-1EVP_CIPH_FLAG_CUSTOM_CIPHER\s0\fR is set for the
cipher.  \fBEVP_Cipher()\fR returns 1 on success or 0 on failure, if the flag
\&\fB\s-1EVP_CIPH_FLAG_CUSTOM_CIPHER\s0\fR is not set for the cipher.
.PP
\&\fBEVP_CIPHER_CTX_reset()\fR returns 1 for success and 0 for failure.
.PP
\&\fBEVP_get_cipherbyname()\fR, \fBEVP_get_cipherbynid()\fR and \fBEVP_get_cipherbyobj()\fR
return an \fB\s-1EVP_CIPHER\s0\fR structure or \s-1NULL\s0 on error.
.PP
\&\fBEVP_CIPHER_nid()\fR and \fBEVP_CIPHER_CTX_nid()\fR return a \s-1NID.\s0
.PP
\&\fBEVP_CIPHER_block_size()\fR and \fBEVP_CIPHER_CTX_block_size()\fR return the block
size.
.PP
\&\fBEVP_CIPHER_key_length()\fR and \fBEVP_CIPHER_CTX_key_length()\fR return the key
length.
.PP
\&\fBEVP_CIPHER_CTX_set_padding()\fR always returns 1.
.PP
\&\fBEVP_CIPHER_iv_length()\fR and \fBEVP_CIPHER_CTX_iv_length()\fR return the \s-1IV\s0
length or zero if the cipher does not use an \s-1IV.\s0
.PP
\&\fBEVP_CIPHER_CTX_tag_length()\fR return the tag length or zero if the cipher does not
use a tag.
.PP
\&\fBEVP_CIPHER_type()\fR and \fBEVP_CIPHER_CTX_type()\fR return the \s-1NID\s0 of the cipher's
\&\s-1OBJECT IDENTIFIER\s0 or NID_undef if it has no defined \s-1OBJECT IDENTIFIER.\s0
.PP
\&\fBEVP_CIPHER_CTX_cipher()\fR returns an \fB\s-1EVP_CIPHER\s0\fR structure.
.PP
\&\fBEVP_CIPHER_param_to_asn1()\fR and \fBEVP_CIPHER_asn1_to_param()\fR return greater
than zero for success and zero or a negative number on failure.
.PP
\&\fBEVP_CIPHER_CTX_rand_key()\fR returns 1 for success.
.SH "CIPHER LISTING"
.IX Header "CIPHER LISTING"
All algorithms have a fixed key length unless otherwise stated.
.PP
Refer to \*(L"\s-1SEE ALSO\*(R"\s0 for the full list of ciphers available through the \s-1EVP\s0
interface.
.IP "\fBEVP_enc_null()\fR" 4
.IX Item "EVP_enc_null()"
Null cipher: does nothing.
.SH "AEAD INTERFACE"
.IX Header "AEAD INTERFACE"
The \s-1EVP\s0 interface for Authenticated Encryption with Associated Data (\s-1AEAD\s0)
modes are subtly altered and several additional \fIctrl\fR operations are supported
depending on the mode specified.
.PP
To specify additional authenticated data (\s-1AAD\s0), a call to \fBEVP_CipherUpdate()\fR,
\&\fBEVP_EncryptUpdate()\fR or \fBEVP_DecryptUpdate()\fR should be made with the output
parameter \fBout\fR set to \fB\s-1NULL\s0\fR.
.PP
When decrypting, the return value of \fBEVP_DecryptFinal()\fR or \fBEVP_CipherFinal()\fR
indicates whether the operation was successful. If it does not indicate success,
the authentication operation has failed and any output data \fB\s-1MUST NOT\s0\fR be used
as it is corrupted.
.SS "\s-1GCM\s0 and \s-1OCB\s0 Modes"
.IX Subsection "GCM and OCB Modes"
The following \fIctrl\fRs are supported in \s-1GCM\s0 and \s-1OCB\s0 modes.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_IVLEN,\s0 ivlen, \s-1NULL\s0)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)"
Sets the \s-1IV\s0 length. This call can only be made before specifying an \s-1IV.\s0 If
not called a default \s-1IV\s0 length is used.
.Sp
For \s-1GCM AES\s0 and \s-1OCB AES\s0 the default is 12 (i.e. 96 bits). For \s-1OCB\s0 mode the
maximum is 15.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_GET_TAG,\s0 taglen, tag)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag)"
Writes \f(CW\*(C`taglen\*(C'\fR bytes of the tag value to the buffer indicated by \f(CW\*(C`tag\*(C'\fR.
This call can only be made when encrypting data and \fBafter\fR all data has been
processed (e.g. after an \fBEVP_EncryptFinal()\fR call).
.Sp
For \s-1OCB,\s0 \f(CW\*(C`taglen\*(C'\fR must either be 16 or the value previously set via
\&\fB\s-1EVP_CTRL_AEAD_SET_TAG\s0\fR.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_TAG,\s0 taglen, tag)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)"
Sets the expected tag to \f(CW\*(C`taglen\*(C'\fR bytes from \f(CW\*(C`tag\*(C'\fR.
The tag length can only be set before specifying an \s-1IV.\s0
\&\f(CW\*(C`taglen\*(C'\fR must be between 1 and 16 inclusive.
.Sp
For \s-1GCM,\s0 this call is only valid when decrypting data.
.Sp
For \s-1OCB,\s0 this call is valid when decrypting data to set the expected tag,
and before encryption to set the desired tag length.
.Sp
In \s-1OCB\s0 mode, calling this before encryption with \f(CW\*(C`tag\*(C'\fR set to \f(CW\*(C`NULL\*(C'\fR sets the
tag length.  If this is not called prior to encryption, a default tag length is
used.
.Sp
For \s-1OCB AES,\s0 the default tag length is 16 (i.e. 128 bits).  It is also the
maximum tag length for \s-1OCB.\s0
.SS "\s-1CCM\s0 Mode"
.IX Subsection "CCM Mode"
The \s-1EVP\s0 interface for \s-1CCM\s0 mode is similar to that of the \s-1GCM\s0 mode but with a
few additional requirements and different \fIctrl\fR values.
.PP
For \s-1CCM\s0 mode, the total plaintext or ciphertext length \fB\s-1MUST\s0\fR be passed to
\&\fBEVP_CipherUpdate()\fR, \fBEVP_EncryptUpdate()\fR or \fBEVP_DecryptUpdate()\fR with the output
and input parameters (\fBin\fR and \fBout\fR) set to \fB\s-1NULL\s0\fR and the length passed in
the \fBinl\fR parameter.
.PP
The following \fIctrl\fRs are supported in \s-1CCM\s0 mode.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_TAG,\s0 taglen, tag)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)"
This call is made to set the expected \fB\s-1CCM\s0\fR tag value when decrypting or
the length of the tag (with the \f(CW\*(C`tag\*(C'\fR parameter set to \s-1NULL\s0) when encrypting.
The tag length is often referred to as \fBM\fR. If not set a default value is
used (12 for \s-1AES\s0). When decrypting, the tag needs to be set before passing
in data to be decrypted, but as in \s-1GCM\s0 and \s-1OCB\s0 mode, it can be set after
passing additional authenticated data (see \*(L"\s-1AEAD INTERFACE\*(R"\s0).
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_CCM_SET_L,\s0 ivlen, \s-1NULL\s0)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL)"
Sets the \s-1CCM\s0 \fBL\fR value. If not set a default is used (8 for \s-1AES\s0).
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_IVLEN,\s0 ivlen, \s-1NULL\s0)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)"
Sets the \s-1CCM\s0 nonce (\s-1IV\s0) length. This call can only be made before specifying a 
nonce value. The nonce length is given by \fB15 \- L\fR so it is 7 by default for
\&\s-1AES.\s0
.SS "\s-1SIV\s0 Mode"
.IX Subsection "SIV Mode"
For \s-1SIV\s0 mode ciphers the behaviour of the \s-1EVP\s0 interface is subtly
altered and several additional ctrl operations are supported.
.PP
To specify any additional authenticated data (\s-1AAD\s0) and/or a Nonce, a call to
\&\fBEVP_CipherUpdate()\fR, \fBEVP_EncryptUpdate()\fR or \fBEVP_DecryptUpdate()\fR should be made
with the output parameter \fBout\fR set to \fB\s-1NULL\s0\fR.
.PP
\&\s-1RFC5297\s0 states that the Nonce is the last piece of \s-1AAD\s0 before the actual
encrypt/decrypt takes place. The \s-1API\s0 does not differentiate the Nonce from
other \s-1AAD.\s0
.PP
When decrypting the return value of \fBEVP_DecryptFinal()\fR or \fBEVP_CipherFinal()\fR
indicates if the operation was successful. If it does not indicate success
the authentication operation has failed and any output data \fB\s-1MUST NOT\s0\fR
be used as it is corrupted.
.PP
The following ctrls are supported in both \s-1SIV\s0 modes.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_GET_TAG,\s0 taglen, tag);" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag);"
Writes \fBtaglen\fR bytes of the tag value to the buffer indicated by \fBtag\fR.
This call can only be made when encrypting data and \fBafter\fR all data has been
processed (e.g. after an \fBEVP_EncryptFinal()\fR call). For \s-1SIV\s0 mode the taglen must
be 16.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_TAG,\s0 taglen, tag);" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag);"
Sets the expected tag to \fBtaglen\fR bytes from \fBtag\fR. This call is only legal
when decrypting data and must be made \fBbefore\fR any data is processed (e.g.
before any \fBEVP_DecryptUpdate()\fR call). For \s-1SIV\s0 mode the taglen must be 16.
.PP
\&\s-1SIV\s0 mode makes two passes over the input data, thus, only one call to
\&\fBEVP_CipherUpdate()\fR, \fBEVP_EncryptUpdate()\fR or \fBEVP_DecryptUpdate()\fR should be made
with \fBout\fR set to a non\-\fB\s-1NULL\s0\fR value. A call to \fBEVP_Decrypt_Final()\fR or
\&\fBEVP_CipherFinal()\fR is not required, but will indicate if the update
operation succeeded.
.SS "ChaCha20\-Poly1305"
.IX Subsection "ChaCha20-Poly1305"
The following \fIctrl\fRs are supported for the ChaCha20\-Poly1305 \s-1AEAD\s0 algorithm.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_IVLEN,\s0 ivlen, \s-1NULL\s0)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)"
Sets the nonce length. This call can only be made before specifying the nonce.
If not called a default nonce length of 12 (i.e. 96 bits) is used. The maximum
nonce length is 12 bytes (i.e. 96\-bits). If a nonce of less than 12 bytes is set
then the nonce is automatically padded with leading 0 bytes to make it 12 bytes
in length.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_GET_TAG,\s0 taglen, tag)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag)"
Writes \f(CW\*(C`taglen\*(C'\fR bytes of the tag value to the buffer indicated by \f(CW\*(C`tag\*(C'\fR.
This call can only be made when encrypting data and \fBafter\fR all data has been
processed (e.g. after an \fBEVP_EncryptFinal()\fR call).
.Sp
\&\f(CW\*(C`taglen\*(C'\fR specified here must be 16 (\fB\s-1POLY1305_BLOCK_SIZE\s0\fR, i.e. 128\-bits) or
less.
.IP "EVP_CIPHER_CTX_ctrl(ctx, \s-1EVP_CTRL_AEAD_SET_TAG,\s0 taglen, tag)" 4
.IX Item "EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)"
Sets the expected tag to \f(CW\*(C`taglen\*(C'\fR bytes from \f(CW\*(C`tag\*(C'\fR.
The tag length can only be set before specifying an \s-1IV.\s0
\&\f(CW\*(C`taglen\*(C'\fR must be between 1 and 16 (\fB\s-1POLY1305_BLOCK_SIZE\s0\fR) inclusive.
This call is only valid when decrypting data.
.SH "NOTES"
.IX Header "NOTES"
Where possible the \fB\s-1EVP\s0\fR interface to symmetric ciphers should be used in
preference to the low-level interfaces. This is because the code then becomes
transparent to the cipher used and much more flexible. Additionally, the
\&\fB\s-1EVP\s0\fR interface will ensure the use of platform specific cryptographic
acceleration such as AES-NI (the low-level interfaces do not provide the
guarantee).
.PP
\&\s-1PKCS\s0 padding works by adding \fBn\fR padding bytes of value \fBn\fR to make the total
length of the encrypted data a multiple of the block size. Padding is always
added so if the data is already a multiple of the block size \fBn\fR will equal
the block size. For example if the block size is 8 and 11 bytes are to be
encrypted then 5 padding bytes of value 5 will be added.
.PP
When decrypting the final block is checked to see if it has the correct form.
.PP
Although the decryption operation can produce an error if padding is enabled,
it is not a strong test that the input data or key is correct. A random block
has better than 1 in 256 chance of being of the correct format and problems with
the input data earlier on will not produce a final decrypt error.
.PP
If padding is disabled then the decryption operation will always succeed if
the total amount of data decrypted is a multiple of the block size.
.PP
The functions \fBEVP_EncryptInit()\fR, \fBEVP_EncryptFinal()\fR, \fBEVP_DecryptInit()\fR,
\&\fBEVP_CipherInit()\fR and \fBEVP_CipherFinal()\fR are obsolete but are retained for
compatibility with existing code. New code should use \fBEVP_EncryptInit_ex()\fR,
\&\fBEVP_EncryptFinal_ex()\fR, \fBEVP_DecryptInit_ex()\fR, \fBEVP_DecryptFinal_ex()\fR,
\&\fBEVP_CipherInit_ex()\fR and \fBEVP_CipherFinal_ex()\fR because they can reuse an
existing context without allocating and freeing it up on each call.
.PP
There are some differences between functions \fBEVP_CipherInit()\fR and
\&\fBEVP_CipherInit_ex()\fR, significant in some circumstances. \fBEVP_CipherInit()\fR fills
the passed context object with zeros.  As a consequence, \fBEVP_CipherInit()\fR does
not allow step-by-step initialization of the ctx when the \fIkey\fR and \fIiv\fR are
passed in separate calls. It also means that the flags set for the \s-1CTX\s0 are
removed, and it is especially important for the
\&\fB\s-1EVP_CIPHER_CTX_FLAG_WRAP_ALLOW\s0\fR flag treated specially in
\&\fBEVP_CipherInit_ex()\fR.
.PP
\&\fBEVP_get_cipherbynid()\fR, and \fBEVP_get_cipherbyobj()\fR are implemented as macros.
.SH "BUGS"
.IX Header "BUGS"
\&\fB\s-1EVP_MAX_KEY_LENGTH\s0\fR and \fB\s-1EVP_MAX_IV_LENGTH\s0\fR only refer to the internal
ciphers with default key lengths. If custom ciphers exceed these values the
results are unpredictable. This is because it has become standard practice to
define a generic key as a fixed unsigned char array containing
\&\fB\s-1EVP_MAX_KEY_LENGTH\s0\fR bytes.
.PP
The \s-1ASN1\s0 code is incomplete (and sometimes inaccurate) it has only been tested
for certain common S/MIME ciphers (\s-1RC2, DES,\s0 triple \s-1DES\s0) in \s-1CBC\s0 mode.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Encrypt a string using \s-1IDEA:\s0
.PP
.Vb 10
\& int do_crypt(char *outfile)
\& {
\&     unsigned char outbuf[1024];
\&     int outlen, tmplen;
\&     /*
\&      * Bogus key and IV: we\*(Aqd normally set these from
\&      * another source.
\&      */
\&     unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
\&     unsigned char iv[] = {1,2,3,4,5,6,7,8};
\&     char intext[] = "Some Crypto Text";
\&     EVP_CIPHER_CTX *ctx;
\&     FILE *out;
\&
\&     ctx = EVP_CIPHER_CTX_new();
\&     EVP_EncryptInit_ex(ctx, EVP_idea_cbc(), NULL, key, iv);
\&
\&     if (!EVP_EncryptUpdate(ctx, outbuf, &outlen, intext, strlen(intext))) {
\&         /* Error */
\&         EVP_CIPHER_CTX_free(ctx);
\&         return 0;
\&     }
\&     /*
\&      * Buffer passed to EVP_EncryptFinal() must be after data just
\&      * encrypted to avoid overwriting it.
\&      */
\&     if (!EVP_EncryptFinal_ex(ctx, outbuf + outlen, &tmplen)) {
\&         /* Error */
\&         EVP_CIPHER_CTX_free(ctx);
\&         return 0;
\&     }
\&     outlen += tmplen;
\&     EVP_CIPHER_CTX_free(ctx);
\&     /*
\&      * Need binary mode for fopen because encrypted data is
\&      * binary data. Also cannot use strlen() on it because
\&      * it won\*(Aqt be NUL terminated and may contain embedded
\&      * NULs.
\&      */
\&     out = fopen(outfile, "wb");
\&     if (out == NULL) {
\&         /* Error */
\&         return 0;
\&     }
\&     fwrite(outbuf, 1, outlen, out);
\&     fclose(out);
\&     return 1;
\& }
.Ve
.PP
The ciphertext from the above example can be decrypted using the \fBopenssl\fR
utility with the command line (shown on two lines for clarity):
.PP
.Vb 2
\& openssl idea \-d \e
\&     \-K 000102030405060708090A0B0C0D0E0F \-iv 0102030405060708 <filename
.Ve
.PP
General encryption and decryption function example using \s-1FILE I/O\s0 and \s-1AES128\s0
with a 128\-bit key:
.PP
.Vb 12
\& int do_crypt(FILE *in, FILE *out, int do_encrypt)
\& {
\&     /* Allow enough space in output buffer for additional block */
\&     unsigned char inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
\&     int inlen, outlen;
\&     EVP_CIPHER_CTX *ctx;
\&     /*
\&      * Bogus key and IV: we\*(Aqd normally set these from
\&      * another source.
\&      */
\&     unsigned char key[] = "0123456789abcdeF";
\&     unsigned char iv[] = "1234567887654321";
\&
\&     /* Don\*(Aqt set key or IV right away; we want to check lengths */
\&     ctx = EVP_CIPHER_CTX_new();
\&     EVP_CipherInit_ex(ctx, EVP_aes_128_cbc(), NULL, NULL, NULL,
\&                       do_encrypt);
\&     OPENSSL_assert(EVP_CIPHER_CTX_key_length(ctx) == 16);
\&     OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) == 16);
\&
\&     /* Now we can set key and IV */
\&     EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, do_encrypt);
\&
\&     for (;;) {
\&         inlen = fread(inbuf, 1, 1024, in);
\&         if (inlen <= 0)
\&             break;
\&         if (!EVP_CipherUpdate(ctx, outbuf, &outlen, inbuf, inlen)) {
\&             /* Error */
\&             EVP_CIPHER_CTX_free(ctx);
\&             return 0;
\&         }
\&         fwrite(outbuf, 1, outlen, out);
\&     }
\&     if (!EVP_CipherFinal_ex(ctx, outbuf, &outlen)) {
\&         /* Error */
\&         EVP_CIPHER_CTX_free(ctx);
\&         return 0;
\&     }
\&     fwrite(outbuf, 1, outlen, out);
\&
\&     EVP_CIPHER_CTX_free(ctx);
\&     return 1;
\& }
.Ve
.PP
Encryption using AES-CBC with a 256\-bit key with \*(L"\s-1CS1\*(R"\s0 ciphertext stealing.
.PP
.Vb 10
\& int encrypt(const unsigned char *key, const unsigned char *iv,
\&             const unsigned char *msg, size_t msg_len, unsigned char *out)
\& {
\&    /*
\&     * This assumes that key size is 32 bytes and the iv is 16 bytes.
\&     * For ciphertext stealing mode the length of the ciphertext "out" will be
\&     * the same size as the plaintext size "msg_len".
\&     * The "msg_len" can be any size >= 16.
\&     */
\&     int ret = 0, encrypt = 1, outlen, len;
\&     EVP_CIPHER_CTX *ctx = NULL;
\&     EVP_CIPHER *cipher = NULL;
\&     OSSL_PARAM params[2];
\&
\&     ctx = EVP_CIPHER_CTX_new();
\&     cipher = EVP_CIPHER_fetch(NULL, "AES\-256\-CBC\-CTS", NULL);
\&     if (ctx == NULL || cipher == NULL)
\&         goto err;
\&
\&     if (!EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, encrypt))
\&         goto err;
\&     /*
\&      * The default is "CS1" so this is not really needed,
\&      * but would be needed to set either "CS2" or "CS3".
\&      */
\&     params[0] = OSSL_PARAM_construct_utf8_string(OSSL_CIPHER_PARAM_CTS_MODE,
\&                                                  "CS1", 0);
\&     params[1] = OSSL_PARAM_construct_end();
\&     if (!EVP_CIPHER_CTX_set_params(ctx, params))
\&         goto err;
\&
\&     /* NOTE: CTS mode does not support multiple calls to EVP_CipherUpdate() */
\&     if (!EVP_CipherUpdate(ctx, encrypted, &outlen, msg, msglen))
\&         goto err;
\&      if (!EVP_CipherFinal_ex(ctx, encrypted + outlen, &len))
\&         goto err;
\&     ret = 1;
\& err:
\&     EVP_CIPHER_free(cipher);
\&     EVP_CIPHER_CTX_free(ctx);
\&     return ret;
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBevp\fR\|(7)
.PP
Supported ciphers are listed in:
.PP
\&\fBEVP_aes_128_gcm\fR\|(3),
\&\fBEVP_aria_128_gcm\fR\|(3),
\&\fBEVP_bf_cbc\fR\|(3),
\&\fBEVP_camellia_128_ecb\fR\|(3),
\&\fBEVP_cast5_cbc\fR\|(3),
\&\fBEVP_chacha20\fR\|(3),
\&\fBEVP_des_cbc\fR\|(3),
\&\fBEVP_desx_cbc\fR\|(3),
\&\fBEVP_idea_cbc\fR\|(3),
\&\fBEVP_rc2_cbc\fR\|(3),
\&\fBEVP_rc4\fR\|(3),
\&\fBEVP_rc5_32_12_16_cbc\fR\|(3),
\&\fBEVP_seed_cbc\fR\|(3),
\&\fBEVP_sm4_cbc\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
Support for \s-1OCB\s0 mode was added in OpenSSL 1.1.0.
.PP
\&\fB\s-1EVP_CIPHER_CTX\s0\fR was made opaque in OpenSSL 1.1.0.  As a result,
\&\fBEVP_CIPHER_CTX_reset()\fR appeared and \fBEVP_CIPHER_CTX_cleanup()\fR
disappeared.  \fBEVP_CIPHER_CTX_init()\fR remains as an alias for
\&\fBEVP_CIPHER_CTX_reset()\fR.
.PP
The \fBEVP_CIPHER_fetch()\fR, \fBEVP_CIPHER_free()\fR, \fBEVP_CIPHER_up_ref()\fR,
\&\fBEVP_CIPHER_CTX_set_params()\fR and \fBEVP_CIPHER_CTX_get_params()\fR functions
were added in 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
