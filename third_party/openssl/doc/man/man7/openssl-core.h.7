.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL-CORE.H 7"
.TH OPENSSL-CORE.H 7 "2020-09-17" "3.0.0-alpha7-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
openssl/core.h \- OpenSSL Core types
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/core.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fI<openssl/core.h>\fR header defines a number of public types that
are used to communicate between the OpenSSL libraries and
implementation providers.
These types are designed to minimise the need for intimate knowledge
of internal structures between the OpenSSL libraries and the providers.
.PP
The types are:
.IP "\fB\s-1OSSL_DISPATCH\s0\fR" 4
.IX Item "OSSL_DISPATCH"
This type is a tuple of function identity and function pointer.
Arrays of this type are passed between the OpenSSL libraries and the
providers to describe what functionality one side provides to the
other.
Arrays of this type must be terminated with a tuple having function
identity zero and function pointer \s-1NULL.\s0
.Sp
The available function identities and corresponding function
signatures are defined in \fBopenssl\-core_dispatch.h\fR\|(7).
.Sp
Any function identity not recognised by the recipient of this type
will be ignored.
This ensures that providers built with one OpenSSL version in mind
will work together with any other OpenSSL version that supports this
mechanism.
.IP "\fB\s-1OSSL_ITEM\s0\fR" 4
.IX Item "OSSL_ITEM"
This type is a tuple of integer and pointer.
It's a generic type used as a generic descriptor, its exact meaning
being defined by how it's used.
Arrays of this type are passed between the OpenSSL libraries and the
providers, and must be terminated with a tuple where the integer is
zero and the pointer \s-1NULL.\s0
.IP "\fB\s-1OSSL_ALGORITHM\s0\fR" 4
.IX Item "OSSL_ALGORITHM"
This type is a tuple of an algorithm name (string), a property
definition (string) and a dispatch table (array of \fB\s-1OSSL_DISPATCH\s0\fR).
Arrays of this type are passed on demand from the providers to the
OpenSSL libraries to describe what algorithms the providers provide
implementations of, and with what properties.
Arrays of this type must be terminated with a tuple having function
identity zero and function pointer \s-1NULL.\s0
.Sp
The algorithm names and property definitions are defined by the
providers.
.IP "\fB\s-1OSSL_PARAM\s0\fR" 4
.IX Item "OSSL_PARAM"
This type is a structure that allows passing arbitrary object data
between two parties that have no or very little shared knowledge about
their respective internal structures for that object. 
It's normally passed in arrays, where the array is terminated with an
element where all fields are zero (for non-pointers) or \s-1NULL\s0 (for
pointers).
.Sp
These arrays can be used to set parameters for some object, to request
parameters, and to describe parameters.
.Sp
\&\fB\s-1OSSL_PARAM\s0\fR is further described in \s-1\fBOSSL_PARAM\s0\fR\|(3)
.IP "\fB\s-1OSSL_CALLBACK\s0\fR" 4
.IX Item "OSSL_CALLBACK"
This is a function type for a generic feedback callback function:
.Sp
.Vb 1
\&    typedef int (OSSL_CALLBACK)(const OSSL_PARAM params[], void *arg);
.Ve
.Sp
A function that takes a pointer of this type should also take a
pointer to caller data.  When calling this callback, the function is
expected to build an \fB\s-1OSSL_PARAM\s0\fR array of data it wants or is
expected to pass back, and pass that as \fIparams\fR, as well as
the caller data pointer it received, as \fIarg\fR.
.IP "\fB\s-1OSSL_PASSPHRASE_CALLBACK\s0\fR" 4
.IX Item "OSSL_PASSPHRASE_CALLBACK"
This is a function type for a generic pass phrase callback function:
.Sp
.Vb 4
\&    typedef int (OSSL_PASSPHRASE_CALLBACK)(char *pass, size_t pass_size,
\&                                           size_t *pass_len,
\&                                           const OSSL_PARAM params[],
\&                                           void *arg);
.Ve
.Sp
This callback can be used to prompt the user for a passphrase.  When
calling it, a buffer to store the pass phrase needs to be given with
\&\fIpass\fR, and its size with \fIpass_size\fR.  The length of the prompted
pass phrase will be given back in \fI*pass_len\fR.
.Sp
Additional parameters can be passed with the \fB\s-1OSSL_PARAM\s0\fR array
\&\fIparams\fR.
.Sp
A function that takes a pointer of this type should also take a
pointer to caller data, which should be passed as \fIarg\fR to this
callback.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBopenssl\-core_dispatch.h\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The types described here were added in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2019\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
