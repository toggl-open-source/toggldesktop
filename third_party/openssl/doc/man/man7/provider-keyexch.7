.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PROVIDER-KEYEXCH 7"
.TH PROVIDER-KEYEXCH 7 "2020-09-17" "3.0.0-alpha7-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
provider\-keyexch \- The keyexch library <\-> provider functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& #include <openssl/core_dispatch.h>
\& #include <openssl/core_names.h>
\&
\& /*
\&  * None of these are actual functions, but are displayed like this for
\&  * the function signatures for functions that are offered as function
\&  * pointers in OSSL_DISPATCH arrays.
\&  */
\&
\& /* Context management */
\& void *OSSL_FUNC_keyexch_newctx(void *provctx);
\& void OSSL_FUNC_keyexch_freectx(void *ctx);
\& void *OSSL_FUNC_keyexch_dupctx(void *ctx);
\&
\& /* Shared secret derivation */
\& int OSSL_FUNC_keyexch_init(void *ctx, void *provkey);
\& int OSSL_FUNC_keyexch_set_peer(void *ctx, void *provkey);
\& int OSSL_FUNC_keyexch_derive(void *ctx, unsigned char *secret, size_t *secretlen,
\&                              size_t outlen);
\&
\& /* Key Exchange parameters */
\& int OSSL_FUNC_keyexch_set_ctx_params(void *ctx, const OSSL_PARAM params[]);
\& const OSSL_PARAM *OSSL_FUNC_keyexch_settable_ctx_params(void *provctx);
\& int OSSL_FUNC_keyexch_get_ctx_params(void *ctx, OSSL_PARAM params[]);
\& const OSSL_PARAM *OSSL_FUNC_keyexch_gettable_ctx_params(void *provctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documentation is primarily aimed at provider authors. See \fBprovider\fR\|(7)
for further information.
.PP
The key exchange (\s-1OSSL_OP_KEYEXCH\s0) operation enables providers to implement key
exchange algorithms and make them available to applications via 
\&\fBEVP_PKEY_derive\fR\|(3) and
other related functions).
.PP
All \*(L"functions\*(R" mentioned here are passed as function pointers between
\&\fIlibcrypto\fR and the provider in \fB\s-1OSSL_DISPATCH\s0\fR arrays via
\&\fB\s-1OSSL_ALGORITHM\s0\fR arrays that are returned by the provider's
\&\fBprovider_query_operation()\fR function
(see \*(L"Provider Functions\*(R" in \fBprovider\-base\fR\|(7)).
.PP
All these \*(L"functions\*(R" have a corresponding function type definition
named \fBOSSL_{name}_fn\fR, and a helper function to retrieve the
function pointer from an \fB\s-1OSSL_DISPATCH\s0\fR element named
\&\fBOSSL_FUNC_{name}\fR.
For example, the \*(L"function\*(R" \fBOSSL_FUNC_keyexch_newctx()\fR has these:
.PP
.Vb 3
\& typedef void *(OSSL_FUNC_keyexch_newctx_fn)(void *provctx);
\& static ossl_inline OSSL_FUNC_keyexch_newctx_fn
\&     OSSL_FUNC_keyexch_newctx(const OSSL_DISPATCH *opf);
.Ve
.PP
\&\fB\s-1OSSL_DISPATCH\s0\fR arrays are indexed by numbers that are provided as
macros in \fBopenssl\-core_dispatch.h\fR\|(7), as follows:
.PP
.Vb 3
\& OSSL_FUNC_keyexch_newctx                OSSL_FUNC_KEYEXCH_NEWCTX
\& OSSL_FUNC_keyexch_freectx               OSSL_FUNC_KEYEXCH_FREECTX
\& OSSL_FUNC_keyexch_dupctx                OSSL_FUNC_KEYEXCH_DUPCTX
\&
\& OSSL_FUNC_keyexch_init                  OSSL_FUNC_KEYEXCH_INIT
\& OSSL_FUNC_keyexch_set_peer              OSSL_FUNC_KEYEXCH_SET_PEER
\& OSSL_FUNC_keyexch_derive                OSSL_FUNC_KEYEXCH_DERIVE
\&
\& OSSL_FUNC_keyexch_set_ctx_params        OSSL_FUNC_KEYEXCH_SET_CTX_PARAMS
\& OSSL_FUNC_keyexch_settable_ctx_params   OSSL_FUNC_KEYEXCH_SETTABLE_CTX_PARAMS
\& OSSL_FUNC_keyexch_get_ctx_params        OSSL_FUNC_KEYEXCH_GET_CTX_PARAMS
\& OSSL_FUNC_keyexch_gettable_ctx_params   OSSL_FUNC_KEYEXCH_GETTABLE_CTX_PARAMS
.Ve
.PP
A key exchange algorithm implementation may not implement all of these functions.
In order to be a consistent set of functions a provider must implement
OSSL_FUNC_keyexch_newctx, OSSL_FUNC_keyexch_freectx, OSSL_FUNC_keyexch_init and OSSL_FUNC_keyexch_derive.
All other functions are optional.
.PP
A key exchange algorithm must also implement some mechanism for generating,
loading or importing keys via the key management (\s-1OSSL_OP_KEYMGMT\s0) operation.
See \fBprovider\-keymgmt\fR\|(7) for further details.
.SS "Context Management Functions"
.IX Subsection "Context Management Functions"
\&\fBOSSL_FUNC_keyexch_newctx()\fR should create and return a pointer to a provider side
structure for holding context information during a key exchange operation.
A pointer to this context will be passed back in a number of the other key
exchange operation function calls.
The parameter \fIprovctx\fR is the provider context generated during provider
initialisation (see \fBprovider\fR\|(7)).
.PP
\&\fBOSSL_FUNC_keyexch_freectx()\fR is passed a pointer to the provider side key exchange
context in the \fIctx\fR parameter.
This function should free any resources associated with that context.
.PP
\&\fBOSSL_FUNC_keyexch_dupctx()\fR should duplicate the provider side key exchange context in
the \fIctx\fR parameter and return the duplicate copy.
.SS "Shared Secret Derivation Functions"
.IX Subsection "Shared Secret Derivation Functions"
\&\fBOSSL_FUNC_keyexch_init()\fR initialises a key exchange operation given a provider side key
exchange context in the \fIctx\fR parameter, and a pointer to a provider key object
in the \fIprovkey\fR parameter. The key object should have been previously
generated, loaded or imported into the provider using the key management
(\s-1OSSL_OP_KEYMGMT\s0) operation (see \fBprovider\-keymgmt\fR\|(7)>.
.PP
\&\fBOSSL_FUNC_keyexch_set_peer()\fR is called to supply the peer's public key (in the
\&\fIprovkey\fR parameter) to be used when deriving the shared secret.
It is also passed a previously initialised key exchange context in the \fIctx\fR
parameter.
The key object should have been previously generated, loaded or imported into
the provider using the key management (\s-1OSSL_OP_KEYMGMT\s0) operation (see
\&\fBprovider\-keymgmt\fR\|(7)>.
.PP
\&\fBOSSL_FUNC_keyexch_derive()\fR performs the actual key exchange itself by deriving a shared
secret.
A previously initialised key exchange context is passed in the \fIctx\fR
parameter.
The derived secret should be written to the location \fIsecret\fR which should not
exceed \fIoutlen\fR bytes.
The length of the shared secret should be written to \fI*secretlen\fR.
If \fIsecret\fR is \s-1NULL\s0 then the maximum length of the shared secret should be
written to \fI*secretlen\fR.
.SS "Key Exchange Parameters Functions"
.IX Subsection "Key Exchange Parameters Functions"
\&\fBOSSL_FUNC_keyexch_set_ctx_params()\fR sets key exchange parameters associated with the
given provider side key exchange context \fIctx\fR to \fIparams\fR,
see \*(L"Common Key Exchange parameters\*(R".
Any parameter settings are additional to any that were previously set.
.PP
\&\fBOSSL_FUNC_keyexch_get_ctx_params()\fR gets key exchange parameters associated with the
given provider side key exchange context \fIctx\fR into \fIparams\fR,
see \*(L"Common Key Exchange parameters\*(R".
.PP
\&\fBOSSL_FUNC_keyexch_settable_ctx_params()\fR yields a constant \fB\s-1OSSL_PARAM\s0\fR array that
describes the settable parameters, i.e. parameters that can be used with
\&\fBOP_signature_set_ctx_params()\fR.
If \fBOSSL_FUNC_keyexch_settable_ctx_params()\fR is present, \fBOSSL_FUNC_keyexch_set_ctx_params()\fR must
also be present, and vice versa.
Similarly, \fBOSSL_FUNC_keyexch_gettable_ctx_params()\fR yields a constant \fB\s-1OSSL_PARAM\s0\fR
array that describes the gettable parameters, i.e. parameters that can be
handled by \fBOP_signature_get_ctx_params()\fR.
If \fBOSSL_FUNC_keyexch_gettable_ctx_params()\fR is present, \fBOSSL_FUNC_keyexch_get_ctx_params()\fR must
also be present, and vice versa.
See \s-1\fBOSSL_PARAM\s0\fR\|(3) for the use of \fB\s-1OSSL_PARAM\s0\fR as parameter descriptor.
.PP
Notice that not all settable parameters are also gettable, and vice versa.
.SS "Common Key Exchange parameters"
.IX Subsection "Common Key Exchange parameters"
See \s-1\fBOSSL_PARAM\s0\fR\|(3) for further details on the parameters structure used by
the \fBOSSL_FUNC_keyexch_set_ctx_params()\fR and \fBOSSL_FUNC_keyexch_get_ctx_params()\fR functions.
.PP
Common parameters currently recognised by built-in key exchange algorithms are
as follows.
.ie n .IP """pad"" (\fB\s-1OSSL_EXCHANGE_PARAM_PAD\s0\fR) <unsigned integer>" 4
.el .IP "``pad'' (\fB\s-1OSSL_EXCHANGE_PARAM_PAD\s0\fR) <unsigned integer>" 4
.IX Item "pad (OSSL_EXCHANGE_PARAM_PAD) <unsigned integer>"
Sets the padding mode for the associated key exchange ctx.
Setting a value of 1 will turn padding on.
Setting a value of 0 will turn padding off.
If padding is off then the derived shared secret may be smaller than the largest
possible secret size.
If padding is on then the derived shared secret will have its first bytes filled
with 0s where necessary to make the shared secret the same size as the largest
possible secret size.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBOSSL_FUNC_keyexch_newctx()\fR and \fBOSSL_FUNC_keyexch_dupctx()\fR should return the newly created
provider side key exchange context, or \s-1NULL\s0 on failure.
.PP
\&\fBOSSL_FUNC_keyexch_init()\fR, \fBOSSL_FUNC_keyexch_set_peer()\fR, \fBOSSL_FUNC_keyexch_derive()\fR,
\&\fBOSSL_FUNC_keyexch_set_params()\fR, and \fBOSSL_FUNC_keyexch_get_params()\fR should return 1 for success
or 0 on error.
.PP
\&\fBOSSL_FUNC_keyexch_settable_ctx_params()\fR and \fBOSSL_FUNC_keyexch_gettable_ctx_params()\fR should
always return a constant \fB\s-1OSSL_PARAM\s0\fR array.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBprovider\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The provider \s-1KEYEXCH\s0 interface was introduced in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2019\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
